module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateRoute {
  count: Int!
}

type AggregateVehicle {
  count: Int!
}

type BatchPayload {
  count: Long!
}

scalar DateTime

scalar Long

type Mutation {
  createRoute(data: RouteCreateInput!): Route!
  updateRoute(data: RouteUpdateInput!, where: RouteWhereUniqueInput!): Route
  updateManyRoutes(data: RouteUpdateManyMutationInput!, where: RouteWhereInput): BatchPayload!
  upsertRoute(where: RouteWhereUniqueInput!, create: RouteCreateInput!, update: RouteUpdateInput!): Route!
  deleteRoute(where: RouteWhereUniqueInput!): Route
  deleteManyRoutes(where: RouteWhereInput): BatchPayload!
  createVehicle(data: VehicleCreateInput!): Vehicle!
  updateVehicle(data: VehicleUpdateInput!, where: VehicleWhereUniqueInput!): Vehicle
  updateManyVehicles(data: VehicleUpdateManyMutationInput!, where: VehicleWhereInput): BatchPayload!
  upsertVehicle(where: VehicleWhereUniqueInput!, create: VehicleCreateInput!, update: VehicleUpdateInput!): Vehicle!
  deleteVehicle(where: VehicleWhereUniqueInput!): Vehicle
  deleteManyVehicles(where: VehicleWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Query {
  route(where: RouteWhereUniqueInput!): Route
  routes(where: RouteWhereInput, orderBy: RouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Route]!
  routesConnection(where: RouteWhereInput, orderBy: RouteOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RouteConnection!
  vehicle(where: VehicleWhereUniqueInput!): Vehicle
  vehicles(where: VehicleWhereInput, orderBy: VehicleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vehicle]!
  vehiclesConnection(where: VehicleWhereInput, orderBy: VehicleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): VehicleConnection!
  node(id: ID!): Node
}

type Route {
  id: ID!
  name: String!
  vehicles(where: VehicleWhereInput, orderBy: VehicleOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Vehicle!]
}

type RouteConnection {
  pageInfo: PageInfo!
  edges: [RouteEdge]!
  aggregate: AggregateRoute!
}

input RouteCreateInput {
  id: ID
  name: String!
  vehicles: VehicleCreateManyWithoutRouteInput
}

input RouteCreateOneWithoutVehiclesInput {
  create: RouteCreateWithoutVehiclesInput
  connect: RouteWhereUniqueInput
}

input RouteCreateWithoutVehiclesInput {
  id: ID
  name: String!
}

type RouteEdge {
  node: Route!
  cursor: String!
}

enum RouteOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
}

type RoutePreviousValues {
  id: ID!
  name: String!
}

type RouteSubscriptionPayload {
  mutation: MutationType!
  node: Route
  updatedFields: [String!]
  previousValues: RoutePreviousValues
}

input RouteSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RouteWhereInput
  AND: [RouteSubscriptionWhereInput!]
  OR: [RouteSubscriptionWhereInput!]
  NOT: [RouteSubscriptionWhereInput!]
}

input RouteUpdateInput {
  name: String
  vehicles: VehicleUpdateManyWithoutRouteInput
}

input RouteUpdateManyMutationInput {
  name: String
}

input RouteUpdateOneWithoutVehiclesInput {
  create: RouteCreateWithoutVehiclesInput
  update: RouteUpdateWithoutVehiclesDataInput
  upsert: RouteUpsertWithoutVehiclesInput
  delete: Boolean
  disconnect: Boolean
  connect: RouteWhereUniqueInput
}

input RouteUpdateWithoutVehiclesDataInput {
  name: String
}

input RouteUpsertWithoutVehiclesInput {
  update: RouteUpdateWithoutVehiclesDataInput!
  create: RouteCreateWithoutVehiclesInput!
}

input RouteWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  vehicles_every: VehicleWhereInput
  vehicles_some: VehicleWhereInput
  vehicles_none: VehicleWhereInput
  AND: [RouteWhereInput!]
  OR: [RouteWhereInput!]
  NOT: [RouteWhereInput!]
}

input RouteWhereUniqueInput {
  id: ID
}

type Subscription {
  route(where: RouteSubscriptionWhereInput): RouteSubscriptionPayload
  vehicle(where: VehicleSubscriptionWhereInput): VehicleSubscriptionPayload
}

type Vehicle {
  id: ID!
  createdAt: DateTime!
  vehicle_ID: Int
  route: Route
  predictable: Boolean
  run: String!
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

type VehicleConnection {
  pageInfo: PageInfo!
  edges: [VehicleEdge]!
  aggregate: AggregateVehicle!
}

input VehicleCreateInput {
  id: ID
  vehicle_ID: Int
  route: RouteCreateOneWithoutVehiclesInput
  predictable: Boolean
  run: String!
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleCreateManyWithoutRouteInput {
  create: [VehicleCreateWithoutRouteInput!]
  connect: [VehicleWhereUniqueInput!]
}

input VehicleCreateWithoutRouteInput {
  id: ID
  vehicle_ID: Int
  predictable: Boolean
  run: String!
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

type VehicleEdge {
  node: Vehicle!
  cursor: String!
}

enum VehicleOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  vehicle_ID_ASC
  vehicle_ID_DESC
  predictable_ASC
  predictable_DESC
  run_ASC
  run_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  heading_ASC
  heading_DESC
  seconds_since_report_ASC
  seconds_since_report_DESC
  serverTime_ASC
  serverTime_DESC
}

type VehiclePreviousValues {
  id: ID!
  createdAt: DateTime!
  vehicle_ID: Int
  predictable: Boolean
  run: String!
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  vehicle_ID: Int
  vehicle_ID_not: Int
  vehicle_ID_in: [Int!]
  vehicle_ID_not_in: [Int!]
  vehicle_ID_lt: Int
  vehicle_ID_lte: Int
  vehicle_ID_gt: Int
  vehicle_ID_gte: Int
  predictable: Boolean
  predictable_not: Boolean
  run: String
  run_not: String
  run_in: [String!]
  run_not_in: [String!]
  run_lt: String
  run_lte: String
  run_gt: String
  run_gte: String
  run_contains: String
  run_not_contains: String
  run_starts_with: String
  run_not_starts_with: String
  run_ends_with: String
  run_not_ends_with: String
  latitude: String
  latitude_not: String
  latitude_in: [String!]
  latitude_not_in: [String!]
  latitude_lt: String
  latitude_lte: String
  latitude_gt: String
  latitude_gte: String
  latitude_contains: String
  latitude_not_contains: String
  latitude_starts_with: String
  latitude_not_starts_with: String
  latitude_ends_with: String
  latitude_not_ends_with: String
  longitude: String
  longitude_not: String
  longitude_in: [String!]
  longitude_not_in: [String!]
  longitude_lt: String
  longitude_lte: String
  longitude_gt: String
  longitude_gte: String
  longitude_contains: String
  longitude_not_contains: String
  longitude_starts_with: String
  longitude_not_starts_with: String
  longitude_ends_with: String
  longitude_not_ends_with: String
  heading: Int
  heading_not: Int
  heading_in: [Int!]
  heading_not_in: [Int!]
  heading_lt: Int
  heading_lte: Int
  heading_gt: Int
  heading_gte: Int
  seconds_since_report: Int
  seconds_since_report_not: Int
  seconds_since_report_in: [Int!]
  seconds_since_report_not_in: [Int!]
  seconds_since_report_lt: Int
  seconds_since_report_lte: Int
  seconds_since_report_gt: Int
  seconds_since_report_gte: Int
  serverTime: String
  serverTime_not: String
  serverTime_in: [String!]
  serverTime_not_in: [String!]
  serverTime_lt: String
  serverTime_lte: String
  serverTime_gt: String
  serverTime_gte: String
  serverTime_contains: String
  serverTime_not_contains: String
  serverTime_starts_with: String
  serverTime_not_starts_with: String
  serverTime_ends_with: String
  serverTime_not_ends_with: String
  AND: [VehicleScalarWhereInput!]
  OR: [VehicleScalarWhereInput!]
  NOT: [VehicleScalarWhereInput!]
}

type VehicleSubscriptionPayload {
  mutation: MutationType!
  node: Vehicle
  updatedFields: [String!]
  previousValues: VehiclePreviousValues
}

input VehicleSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: VehicleWhereInput
  AND: [VehicleSubscriptionWhereInput!]
  OR: [VehicleSubscriptionWhereInput!]
  NOT: [VehicleSubscriptionWhereInput!]
}

input VehicleUpdateInput {
  vehicle_ID: Int
  route: RouteUpdateOneWithoutVehiclesInput
  predictable: Boolean
  run: String
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleUpdateManyDataInput {
  vehicle_ID: Int
  predictable: Boolean
  run: String
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleUpdateManyMutationInput {
  vehicle_ID: Int
  predictable: Boolean
  run: String
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleUpdateManyWithoutRouteInput {
  create: [VehicleCreateWithoutRouteInput!]
  delete: [VehicleWhereUniqueInput!]
  connect: [VehicleWhereUniqueInput!]
  set: [VehicleWhereUniqueInput!]
  disconnect: [VehicleWhereUniqueInput!]
  update: [VehicleUpdateWithWhereUniqueWithoutRouteInput!]
  upsert: [VehicleUpsertWithWhereUniqueWithoutRouteInput!]
  deleteMany: [VehicleScalarWhereInput!]
  updateMany: [VehicleUpdateManyWithWhereNestedInput!]
}

input VehicleUpdateManyWithWhereNestedInput {
  where: VehicleScalarWhereInput!
  data: VehicleUpdateManyDataInput!
}

input VehicleUpdateWithoutRouteDataInput {
  vehicle_ID: Int
  predictable: Boolean
  run: String
  latitude: String
  longitude: String
  heading: Int
  seconds_since_report: Int
  serverTime: String
}

input VehicleUpdateWithWhereUniqueWithoutRouteInput {
  where: VehicleWhereUniqueInput!
  data: VehicleUpdateWithoutRouteDataInput!
}

input VehicleUpsertWithWhereUniqueWithoutRouteInput {
  where: VehicleWhereUniqueInput!
  update: VehicleUpdateWithoutRouteDataInput!
  create: VehicleCreateWithoutRouteInput!
}

input VehicleWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  vehicle_ID: Int
  vehicle_ID_not: Int
  vehicle_ID_in: [Int!]
  vehicle_ID_not_in: [Int!]
  vehicle_ID_lt: Int
  vehicle_ID_lte: Int
  vehicle_ID_gt: Int
  vehicle_ID_gte: Int
  route: RouteWhereInput
  predictable: Boolean
  predictable_not: Boolean
  run: String
  run_not: String
  run_in: [String!]
  run_not_in: [String!]
  run_lt: String
  run_lte: String
  run_gt: String
  run_gte: String
  run_contains: String
  run_not_contains: String
  run_starts_with: String
  run_not_starts_with: String
  run_ends_with: String
  run_not_ends_with: String
  latitude: String
  latitude_not: String
  latitude_in: [String!]
  latitude_not_in: [String!]
  latitude_lt: String
  latitude_lte: String
  latitude_gt: String
  latitude_gte: String
  latitude_contains: String
  latitude_not_contains: String
  latitude_starts_with: String
  latitude_not_starts_with: String
  latitude_ends_with: String
  latitude_not_ends_with: String
  longitude: String
  longitude_not: String
  longitude_in: [String!]
  longitude_not_in: [String!]
  longitude_lt: String
  longitude_lte: String
  longitude_gt: String
  longitude_gte: String
  longitude_contains: String
  longitude_not_contains: String
  longitude_starts_with: String
  longitude_not_starts_with: String
  longitude_ends_with: String
  longitude_not_ends_with: String
  heading: Int
  heading_not: Int
  heading_in: [Int!]
  heading_not_in: [Int!]
  heading_lt: Int
  heading_lte: Int
  heading_gt: Int
  heading_gte: Int
  seconds_since_report: Int
  seconds_since_report_not: Int
  seconds_since_report_in: [Int!]
  seconds_since_report_not_in: [Int!]
  seconds_since_report_lt: Int
  seconds_since_report_lte: Int
  seconds_since_report_gt: Int
  seconds_since_report_gte: Int
  serverTime: String
  serverTime_not: String
  serverTime_in: [String!]
  serverTime_not_in: [String!]
  serverTime_lt: String
  serverTime_lte: String
  serverTime_gt: String
  serverTime_gte: String
  serverTime_contains: String
  serverTime_not_contains: String
  serverTime_starts_with: String
  serverTime_not_starts_with: String
  serverTime_ends_with: String
  serverTime_not_ends_with: String
  AND: [VehicleWhereInput!]
  OR: [VehicleWhereInput!]
  NOT: [VehicleWhereInput!]
}

input VehicleWhereUniqueInput {
  id: ID
}
`
      }
    